# Section 3 – Building Custom Images Through the Docker Server

This section focuses on creating custom Docker images using a Dockerfile and understanding how Docker builds images step by step.

---

## Dockerfile Overview

A **Dockerfile** is a configuration file that defines how a Docker image should behave.

Every Dockerfile typically follows this structure:
- Specify a base image
- Run commands to install dependencies
- Specify a command to run when the container starts

---

## Dockerfile Instructions

Dockerfiles are made up of instructions that tell the Docker Server what actions to perform.

Common instructions include:
- `FROM`
- `RUN`
- `CMD`

Each instruction expects arguments.

Example:
- `FROM alpine`

---

## Base Images

When creating a Dockerfile, you start with an empty environment.

A **base image**:
- Provides an initial file system and environment
- Acts as the starting point for building your image

Once a base image is defined, you can:
- Install dependencies using `RUN`
- Define startup behavior using `CMD`

---

## Building Your First Dockerfile

Example flow:
- `FROM alpine` defines the base image
- `RUN apk add --update redis` installs Redis
- `CMD redis-server` defines the startup command

These instructions tell Docker how to build and run the container.

---

## Building Images with Docker

To build an image from a Dockerfile, use:

```bash
docker build .
```

This command:
- Looks for a Dockerfile in the current directory
- Builds an image based on the instructions in that Dockerfile

### docker build vs docker run

- `docker run`:
    - Creates and runs a container from an existing image
    - Pulls images from Docker Hub if not available locally

- `docker build`:
    - Builds a new image using a Dockerfile
    - Does not pull application logic from Docker Hub unless specified as a base image

---

## How Docker Builds Images (Behind the Scenes)

For each instruction in a Dockerfile:
1. Docker creates a temporary container from the previous image
2. The instruction is executed as the container’s primary process
3. Docker takes a snapshot of the container’s file system
4. A new image is created for the next instruction to use

Example:
- `FROM alpine` creates an initial image
- `RUN apk add --update redis`:
    - Runs inside a temporary container
    - Installs Redis
    - Produces a new image with Redis installed
- `CMD redis-server`:
    - Defines the startup process
    - Produces the final image

All temporary containers are removed after each step.

---

## Image Layers and Caching

Key takeaways about image building:
- Each instruction creates a new image layer
- Docker reuses cached layers if nothing has changed
- Efficient Dockerfiles place rarely changing steps first

Caching significantly speeds up rebuilds.

---

## Tagging Images

Images can be tagged for easier identification:

```bash
docker build -t <tag-name> .
```

Tags help:
- Identify image purpose and version
- Avoid relying on autogenerated image IDs

---

## Project Location

The files for this hands-on project can be found in the following directory:

`/hands-on/section-3-building-custom-images-through-docker-server/`


## Key Takeaways

- Dockerfiles define how custom images are built
- Images are created step-by-step using instructions
- Each instruction produces a new image layer
- Docker uses caching to optimize builds
- Image tags improve organization and clarity

---

### Quiz Evidence

Quiz results for this section are available here:  
`/quizzes/section-3-building-custom-images-through-docker-server/`
